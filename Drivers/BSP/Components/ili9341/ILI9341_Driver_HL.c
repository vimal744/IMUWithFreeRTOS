/**
 * @file    ILI9341_Driver_HL.c
 */

/* Includes ------------------------------------------------------------------*/
#include "ILI9341_Driver_HL.h"
#include <math.h>


#ifndef min
    #define min(a,b) ((a < b) ? a : b)
#endif

#ifndef abs
    #define abs(a) ((a) < 0 ? -(a) : (a))
#endif

#define pgm_read_byte(addr) (*(const unsigned char *)(addr))

#define MAX_WIDTH   240
#define MAX_HEIGHT  320


// Standard ASCII 5x7 font

static const unsigned char font[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
    0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
    0x18, 0x3C, 0x7E, 0x3C, 0x18,
    0x1C, 0x57, 0x7D, 0x57, 0x1C,
    0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
    0x00, 0x18, 0x3C, 0x18, 0x00,
    0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
    0x00, 0x18, 0x24, 0x18, 0x00,
    0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
    0x30, 0x48, 0x3A, 0x06, 0x0E,
    0x26, 0x29, 0x79, 0x29, 0x26,
    0x40, 0x7F, 0x05, 0x05, 0x07,
    0x40, 0x7F, 0x05, 0x25, 0x3F,
    0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
    0x7F, 0x3E, 0x1C, 0x1C, 0x08,
    0x08, 0x1C, 0x1C, 0x3E, 0x7F,
    0x14, 0x22, 0x7F, 0x22, 0x14,
    0x5F, 0x5F, 0x00, 0x5F, 0x5F,
    0x06, 0x09, 0x7F, 0x01, 0x7F,
    0x00, 0x66, 0x89, 0x95, 0x6A,
    0x60, 0x60, 0x60, 0x60, 0x60,
    0x94, 0xA2, 0xFF, 0xA2, 0x94,
    0x08, 0x04, 0x7E, 0x04, 0x08,
    0x10, 0x20, 0x7E, 0x20, 0x10,
    0x08, 0x08, 0x2A, 0x1C, 0x08,
    0x08, 0x1C, 0x2A, 0x08, 0x08,
    0x1E, 0x10, 0x10, 0x10, 0x10,
    0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
    0x30, 0x38, 0x3E, 0x38, 0x30,
    0x06, 0x0E, 0x3E, 0x0E, 0x06,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x5F, 0x00, 0x00,
    0x00, 0x07, 0x00, 0x07, 0x00,
    0x14, 0x7F, 0x14, 0x7F, 0x14,
    0x24, 0x2A, 0x7F, 0x2A, 0x12,
    0x23, 0x13, 0x08, 0x64, 0x62,
    0x36, 0x49, 0x56, 0x20, 0x50,
    0x00, 0x08, 0x07, 0x03, 0x00,
    0x00, 0x1C, 0x22, 0x41, 0x00,
    0x00, 0x41, 0x22, 0x1C, 0x00,
    0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
    0x08, 0x08, 0x3E, 0x08, 0x08,
    0x00, 0x80, 0x70, 0x30, 0x00,
    0x08, 0x08, 0x08, 0x08, 0x08,
    0x00, 0x00, 0x60, 0x60, 0x00,
    0x20, 0x10, 0x08, 0x04, 0x02,
    0x3E, 0x51, 0x49, 0x45, 0x3E,
    0x00, 0x42, 0x7F, 0x40, 0x00,
    0x72, 0x49, 0x49, 0x49, 0x46,
    0x21, 0x41, 0x49, 0x4D, 0x33,
    0x18, 0x14, 0x12, 0x7F, 0x10,
    0x27, 0x45, 0x45, 0x45, 0x39,
    0x3C, 0x4A, 0x49, 0x49, 0x31,
    0x41, 0x21, 0x11, 0x09, 0x07,
    0x36, 0x49, 0x49, 0x49, 0x36,
    0x46, 0x49, 0x49, 0x29, 0x1E,
    0x00, 0x00, 0x14, 0x00, 0x00,
    0x00, 0x40, 0x34, 0x00, 0x00,
    0x00, 0x08, 0x14, 0x22, 0x41,
    0x14, 0x14, 0x14, 0x14, 0x14,
    0x00, 0x41, 0x22, 0x14, 0x08,
    0x02, 0x01, 0x59, 0x09, 0x06,
    0x3E, 0x41, 0x5D, 0x59, 0x4E,
    0x7C, 0x12, 0x11, 0x12, 0x7C,
    0x7F, 0x49, 0x49, 0x49, 0x36,
    0x3E, 0x41, 0x41, 0x41, 0x22,
    0x7F, 0x41, 0x41, 0x41, 0x3E,
    0x7F, 0x49, 0x49, 0x49, 0x41,
    0x7F, 0x09, 0x09, 0x09, 0x01,
    0x3E, 0x41, 0x41, 0x51, 0x73,
    0x7F, 0x08, 0x08, 0x08, 0x7F,
    0x00, 0x41, 0x7F, 0x41, 0x00,
    0x20, 0x40, 0x41, 0x3F, 0x01,
    0x7F, 0x08, 0x14, 0x22, 0x41,
    0x7F, 0x40, 0x40, 0x40, 0x40,
    0x7F, 0x02, 0x1C, 0x02, 0x7F,
    0x7F, 0x04, 0x08, 0x10, 0x7F,
    0x3E, 0x41, 0x41, 0x41, 0x3E,
    0x7F, 0x09, 0x09, 0x09, 0x06,
    0x3E, 0x41, 0x51, 0x21, 0x5E,
    0x7F, 0x09, 0x19, 0x29, 0x46,
    0x26, 0x49, 0x49, 0x49, 0x32,
    0x03, 0x01, 0x7F, 0x01, 0x03,
    0x3F, 0x40, 0x40, 0x40, 0x3F,
    0x1F, 0x20, 0x40, 0x20, 0x1F,
    0x3F, 0x40, 0x38, 0x40, 0x3F,
    0x63, 0x14, 0x08, 0x14, 0x63,
    0x03, 0x04, 0x78, 0x04, 0x03,
    0x61, 0x59, 0x49, 0x4D, 0x43,
    0x00, 0x7F, 0x41, 0x41, 0x41,
    0x02, 0x04, 0x08, 0x10, 0x20,
    0x00, 0x41, 0x41, 0x41, 0x7F,
    0x04, 0x02, 0x01, 0x02, 0x04,
    0x40, 0x40, 0x40, 0x40, 0x40,
    0x00, 0x03, 0x07, 0x08, 0x00,
    0x20, 0x54, 0x54, 0x78, 0x40,
    0x7F, 0x28, 0x44, 0x44, 0x38,
    0x38, 0x44, 0x44, 0x44, 0x28,
    0x38, 0x44, 0x44, 0x28, 0x7F,
    0x38, 0x54, 0x54, 0x54, 0x18,
    0x00, 0x08, 0x7E, 0x09, 0x02,
    0x18, 0xA4, 0xA4, 0x9C, 0x78,
    0x7F, 0x08, 0x04, 0x04, 0x78,
    0x00, 0x44, 0x7D, 0x40, 0x00,
    0x20, 0x40, 0x40, 0x3D, 0x00,
    0x7F, 0x10, 0x28, 0x44, 0x00,
    0x00, 0x41, 0x7F, 0x40, 0x00,
    0x7C, 0x04, 0x78, 0x04, 0x78,
    0x7C, 0x08, 0x04, 0x04, 0x78,
    0x38, 0x44, 0x44, 0x44, 0x38,
    0xFC, 0x18, 0x24, 0x24, 0x18,
    0x18, 0x24, 0x24, 0x18, 0xFC,
    0x7C, 0x08, 0x04, 0x04, 0x08,
    0x48, 0x54, 0x54, 0x54, 0x24,
    0x04, 0x04, 0x3F, 0x44, 0x24,
    0x3C, 0x40, 0x40, 0x20, 0x7C,
    0x1C, 0x20, 0x40, 0x20, 0x1C,
    0x3C, 0x40, 0x30, 0x40, 0x3C,
    0x44, 0x28, 0x10, 0x28, 0x44,
    0x4C, 0x90, 0x90, 0x90, 0x7C,
    0x44, 0x64, 0x54, 0x4C, 0x44,
    0x00, 0x08, 0x36, 0x41, 0x00,
    0x00, 0x00, 0x77, 0x00, 0x00,
    0x00, 0x41, 0x36, 0x08, 0x00,
    0x02, 0x01, 0x02, 0x04, 0x02,
    0x3C, 0x26, 0x23, 0x26, 0x3C,
    0x1E, 0xA1, 0xA1, 0x61, 0x12,
    0x3A, 0x40, 0x40, 0x20, 0x7A,
    0x38, 0x54, 0x54, 0x55, 0x59,
    0x21, 0x55, 0x55, 0x79, 0x41,
    0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
    0x21, 0x55, 0x54, 0x78, 0x40,
    0x20, 0x54, 0x55, 0x79, 0x40,
    0x0C, 0x1E, 0x52, 0x72, 0x12,
    0x39, 0x55, 0x55, 0x55, 0x59,
    0x39, 0x54, 0x54, 0x54, 0x59,
    0x39, 0x55, 0x54, 0x54, 0x58,
    0x00, 0x00, 0x45, 0x7C, 0x41,
    0x00, 0x02, 0x45, 0x7D, 0x42,
    0x00, 0x01, 0x45, 0x7C, 0x40,
    0x7D, 0x12, 0x11, 0x12, 0x7D, // A-umlaut
    0xF0, 0x28, 0x25, 0x28, 0xF0,
    0x7C, 0x54, 0x55, 0x45, 0x00,
    0x20, 0x54, 0x54, 0x7C, 0x54,
    0x7C, 0x0A, 0x09, 0x7F, 0x49,
    0x32, 0x49, 0x49, 0x49, 0x32,
    0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
    0x32, 0x4A, 0x48, 0x48, 0x30,
    0x3A, 0x41, 0x41, 0x21, 0x7A,
    0x3A, 0x42, 0x40, 0x20, 0x78,
    0x00, 0x9D, 0xA0, 0xA0, 0x7D,
    0x3D, 0x42, 0x42, 0x42, 0x3D, // O-umlaut
    0x3D, 0x40, 0x40, 0x40, 0x3D,
    0x3C, 0x24, 0xFF, 0x24, 0x24,
    0x48, 0x7E, 0x49, 0x43, 0x66,
    0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
    0xFF, 0x09, 0x29, 0xF6, 0x20,
    0xC0, 0x88, 0x7E, 0x09, 0x03,
    0x20, 0x54, 0x54, 0x79, 0x41,
    0x00, 0x00, 0x44, 0x7D, 0x41,
    0x30, 0x48, 0x48, 0x4A, 0x32,
    0x38, 0x40, 0x40, 0x22, 0x7A,
    0x00, 0x7A, 0x0A, 0x0A, 0x72,
    0x7D, 0x0D, 0x19, 0x31, 0x7D,
    0x26, 0x29, 0x29, 0x2F, 0x28,
    0x26, 0x29, 0x29, 0x29, 0x26,
    0x30, 0x48, 0x4D, 0x40, 0x20,
    0x38, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x38,
    0x2F, 0x10, 0xC8, 0xAC, 0xBA,
    0x2F, 0x10, 0x28, 0x34, 0xFA,
    0x00, 0x00, 0x7B, 0x00, 0x00,
    0x08, 0x14, 0x2A, 0x14, 0x22,
    0x22, 0x14, 0x2A, 0x14, 0x08,
    0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old code
    0xAA, 0x55, 0xAA, 0x55, 0xAA, // 50% block
    0xFF, 0x55, 0xFF, 0x55, 0xFF, // 75% block
    0x00, 0x00, 0x00, 0xFF, 0x00,
    0x10, 0x10, 0x10, 0xFF, 0x00,
    0x14, 0x14, 0x14, 0xFF, 0x00,
    0x10, 0x10, 0xFF, 0x00, 0xFF,
    0x10, 0x10, 0xF0, 0x10, 0xF0,
    0x14, 0x14, 0x14, 0xFC, 0x00,
    0x14, 0x14, 0xF7, 0x00, 0xFF,
    0x00, 0x00, 0xFF, 0x00, 0xFF,
    0x14, 0x14, 0xF4, 0x04, 0xFC,
    0x14, 0x14, 0x17, 0x10, 0x1F,
    0x10, 0x10, 0x1F, 0x10, 0x1F,
    0x14, 0x14, 0x14, 0x1F, 0x00,
    0x10, 0x10, 0x10, 0xF0, 0x00,
    0x00, 0x00, 0x00, 0x1F, 0x10,
    0x10, 0x10, 0x10, 0x1F, 0x10,
    0x10, 0x10, 0x10, 0xF0, 0x10,
    0x00, 0x00, 0x00, 0xFF, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x10, 0xFF, 0x10,
    0x00, 0x00, 0x00, 0xFF, 0x14,
    0x00, 0x00, 0xFF, 0x00, 0xFF,
    0x00, 0x00, 0x1F, 0x10, 0x17,
    0x00, 0x00, 0xFC, 0x04, 0xF4,
    0x14, 0x14, 0x17, 0x10, 0x17,
    0x14, 0x14, 0xF4, 0x04, 0xF4,
    0x00, 0x00, 0xFF, 0x00, 0xF7,
    0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x14, 0xF7, 0x00, 0xF7,
    0x14, 0x14, 0x14, 0x17, 0x14,
    0x10, 0x10, 0x1F, 0x10, 0x1F,
    0x14, 0x14, 0x14, 0xF4, 0x14,
    0x10, 0x10, 0xF0, 0x10, 0xF0,
    0x00, 0x00, 0x1F, 0x10, 0x1F,
    0x00, 0x00, 0x00, 0x1F, 0x14,
    0x00, 0x00, 0x00, 0xFC, 0x14,
    0x00, 0x00, 0xF0, 0x10, 0xF0,
    0x10, 0x10, 0xFF, 0x10, 0xFF,
    0x14, 0x14, 0x14, 0xFF, 0x14,
    0x10, 0x10, 0x10, 0x1F, 0x00,
    0x00, 0x00, 0x00, 0xF0, 0x10,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xFF, 0xFF, 0xFF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFF, 0xFF,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0x38, 0x44, 0x44, 0x38, 0x44,
    0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
    0x7E, 0x02, 0x02, 0x06, 0x06,
    0x02, 0x7E, 0x02, 0x7E, 0x02,
    0x63, 0x55, 0x49, 0x41, 0x63,
    0x38, 0x44, 0x44, 0x3C, 0x04,
    0x40, 0x7E, 0x20, 0x1E, 0x20,
    0x06, 0x02, 0x7E, 0x02, 0x02,
    0x99, 0xA5, 0xE7, 0xA5, 0x99,
    0x1C, 0x2A, 0x49, 0x2A, 0x1C,
    0x4C, 0x72, 0x01, 0x72, 0x4C,
    0x30, 0x4A, 0x4D, 0x4D, 0x30,
    0x30, 0x48, 0x78, 0x48, 0x30,
    0xBC, 0x62, 0x5A, 0x46, 0x3D,
    0x3E, 0x49, 0x49, 0x49, 0x00,
    0x7E, 0x01, 0x01, 0x01, 0x7E,
    0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
    0x44, 0x44, 0x5F, 0x44, 0x44,
    0x40, 0x51, 0x4A, 0x44, 0x40,
    0x40, 0x44, 0x4A, 0x51, 0x40,
    0x00, 0x00, 0xFF, 0x01, 0x03,
    0xE0, 0x80, 0xFF, 0x00, 0x00,
    0x08, 0x08, 0x6B, 0x6B, 0x08,
    0x36, 0x12, 0x36, 0x24, 0x36,
    0x06, 0x0F, 0x09, 0x0F, 0x06,
    0x00, 0x00, 0x18, 0x18, 0x00,
    0x00, 0x00, 0x10, 0x10, 0x00,
    0x30, 0x40, 0xFF, 0x01, 0x01,
    0x00, 0x1F, 0x01, 0x01, 0x1E,
    0x00, 0x19, 0x1D, 0x17, 0x12,
    0x00, 0x3C, 0x3C, 0x3C, 0x3C,
    0x00, 0x00, 0x00, 0x00, 0x00  // #255 NBSP
};

static DrvStatusTypeDef ILI9341_D_Init( DrvContextTypeDef *handle );
static DrvStatusTypeDef ILI9341_D_DeInit( DrvContextTypeDef *handle );
static DrvStatusTypeDef ILI9341_D_Display_Enable( DrvContextTypeDef *handle );
static DrvStatusTypeDef ILI9341_D_Display_Disable( DrvContextTypeDef *handle );
static DrvStatusTypeDef ILI9341_D_Display_Fill_Rectange
    (
    DrvContextTypeDef *handle,
    uint16_t color,
    int16_t x,
    int16_t y,
    int16_t w,
    int16_t h
    );
static DrvStatusTypeDef ILI9341_D_Display_Fill_Screen
    (
    DrvContextTypeDef *handle,
    uint16_t color
    );

static DrvStatusTypeDef ILI9341_D_Display_Write_Char( DrvContextTypeDef *handle, unsigned char c );
static DrvStatusTypeDef ILI9341_D_Display_Set_Text_Color( DrvContextTypeDef *handle, uint16_t fg, uint16_t bc );
static DrvStatusTypeDef ILI9341_D_Display_Set_Cursor( DrvContextTypeDef *handle, int16_t x, int16_t y );


static void swap( int16_t a, int16_t b );
static void DrawLine( void *handle, int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color);
static void DrawFastVerticalLine( void* handle, int16_t x, int16_t y, int16_t h, uint16_t color);
static void DrawFastHorizontalLine( void* handle, int16_t x, int16_t y, int16_t w, uint16_t color);
static void FillRect( void* handle, int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);
static void WriteChar(void* handle, uint8_t c);
void DrawChar(void* handle, int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size);

static int16_t  cursor_x    = 0;
static int16_t  cursor_y    = 0;
static uint8_t  textsize    = 2;
static uint16_t textcolor   = 0xFFFF;
static uint16_t textbgcolor = 0xFFFF;
static unsigned char wrap = 1;   // If set, 'wrap' text at right edge of display
static unsigned char _cp437 = 0; // If set, use correct CP437 charset (default is off)


/**
 * @}
 */

/** @addtogroup ILI9341_Private_Function_Prototypes Private function prototypes
 * @{
 */

static DrvStatusTypeDef ILI9341_Init( DrvContextTypeDef *handle );
static DrvStatusTypeDef ILI9341_Display_Enable( DrvContextTypeDef *handle );
static DrvStatusTypeDef ILI9341_Display_Disable( DrvContextTypeDef *handle );

/**
 * @}
 */

/** @addtogroup ILI9341_Private_Variables Private variables
 * @{
 */

/**
 * @brief ILI9341 humidity driver structure
 */
DISPLAY_Drv_t ILI9341_D_Drv =
{
  ILI9341_D_Init,
  ILI9341_D_DeInit,
  ILI9341_D_Display_Enable,
  ILI9341_D_Display_Disable,
  ILI9341_D_Display_Fill_Rectange,
  ILI9341_D_Display_Fill_Screen,
  ILI9341_D_Display_Write_Char,
  ILI9341_D_Display_Set_Cursor,
  ILI9341_D_Display_Set_Text_Color,
};

static DrvStatusTypeDef ILI9341_D_Display_Write_Char( DrvContextTypeDef *handle, unsigned char c )
{
    if( !handle->isInitialized )
    {
        return COMPONENT_ERROR;
    }

    WriteChar( (void*)handle, c );

    return COMPONENT_OK;
}

static DrvStatusTypeDef ILI9341_D_Display_Set_Text_Color( DrvContextTypeDef *handle, uint16_t fg, uint16_t bc )
{
    if( !handle->isInitialized )
    {
        return COMPONENT_ERROR;
    }

    textcolor   = fg;

    textbgcolor = bc;

    return COMPONENT_OK;
}

static DrvStatusTypeDef ILI9341_D_Display_Set_Cursor( DrvContextTypeDef *handle, int16_t x, int16_t y )
{
    if( !handle->isInitialized )
    {
        return COMPONENT_ERROR;
    }

    cursor_x = x;

    cursor_y = y;

    return COMPONENT_OK;
}


/**
 * @brief Initialize the ILI9341 humidity sensor
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef ILI9341_D_Init( DrvContextTypeDef *handle )
{
  if( !handle->isInitialized )
  {
    if(ILI9341_Init(handle) == COMPONENT_ERROR)
    {
      return COMPONENT_ERROR;
    }
  }

  handle->isInitialized = 1;

  return COMPONENT_OK;
}


/**
 * @brief Deinitialize the ILI9341 humidity sensor
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef ILI9341_D_DeInit( DrvContextTypeDef *handle )
{

    if( handle->isInitialized )
    {
        if(ILI9341_D_Display_Disable(handle) == COMPONENT_ERROR)
        {
        return COMPONENT_ERROR;
        }
    }

    handle->isInitialized = 0;

    return COMPONENT_OK;
}

/**
 * @brief Enable the ILI9341 humidity sensor
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef ILI9341_D_Display_Enable( DrvContextTypeDef *handle )
{

    /* Check if the component is already enabled */
    if( handle->isEnabled == 1 )
    {
        return COMPONENT_OK;
    }

    if(ILI9341_Display_Enable(handle) == COMPONENT_ERROR)
    {
        return COMPONENT_ERROR;
    }

    handle->isEnabled = 1;

    return COMPONENT_OK;
}

/**
 * @brief Disable the ILI9341 humidity sensor
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef ILI9341_D_Display_Disable( DrvContextTypeDef *handle )
{

  /* Check if the component is already disabled */
    if( handle->isEnabled == 0 )
    {
        return COMPONENT_OK;
    }

    if(ILI9341_Display_Disable(handle) == COMPONENT_ERROR)
    {
        return COMPONENT_ERROR;
    }

    handle->isEnabled = 0;

    return COMPONENT_OK;
}

static DrvStatusTypeDef ILI9341_D_Display_Fill_Rectange
    (
    DrvContextTypeDef *handle,
    uint16_t color,
    int16_t x,
    int16_t y,
    int16_t w,
    int16_t h
    )
{
  /* Check if the component is already disabled */
    if( handle->isEnabled == 0 )
    {
        return COMPONENT_ERROR;
    }

    if( ILI9341_FillRect(handle, color, x,y,w,h ) == ILI9341_ERROR )
    {
        return COMPONENT_ERROR;
    }

    return COMPONENT_OK;
}

static DrvStatusTypeDef ILI9341_D_Display_Fill_Screen
    (
    DrvContextTypeDef *handle,
    uint16_t color
    )
{
  /* Check if the component is already disabled */
    if( handle->isEnabled == 0 )
    {
        return COMPONENT_ERROR;
    }

    if( ILI9341_FillScreen( handle, color ) == ILI9341_ERROR )
    {
        return COMPONENT_ERROR;
    }

    return COMPONENT_OK;
}

/** @addtogroup ILI9341_Private_Functions Private functions
 * @{
 */

/**
 * @brief Initialize the ILI9341 sensor
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef ILI9341_Init( DrvContextTypeDef *handle )
{

  /* Power down the device */
  if ( ILI9341_DeActivate( (void *)handle ) == ILI9341_ERROR )
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}

/**
 * @brief Enable the ILI9341 sensor
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef ILI9341_Display_Enable( DrvContextTypeDef *handle )
{

  /* Power up the device */
  if ( ILI9341_Activate( (void *)handle ) == ILI9341_ERROR )
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}

/**
 * @brief Disable the ILI9341 sensor
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef ILI9341_Display_Disable( DrvContextTypeDef *handle )
{

  /* Power down the device */
  if ( ILI9341_DeActivate( (void *)handle ) == ILI9341_ERROR )
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}



// Bresenham's algorithm - thx wikpedia
static void DrawLine( void *handle, int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color)
{
      int16_t steep = abs(y1 - y0) > abs(x1 - x0);
      if (steep) {
        swap(x0, y0);
        swap(x1, y1);
      }

      if (x0 > x1) {
        swap(x0, x1);
        swap(y0, y1);
      }

      int16_t dx, dy;
      dx = x1 - x0;
      dy = abs(y1 - y0);

      int16_t err = dx / 2;
      int16_t ystep;

      if (y0 < y1) {
        ystep = 1;
      } else {
        ystep = -1;
      }

      for (; x0<=x1; x0++) {
        if (steep) {
            ILI9341_DrawPixel(handle, y0, x0, color);
        } else {
            ILI9341_DrawPixel(handle, x0, y0, color);
        }
        err -= dy;
        if (err < 0) {
          y0 += ystep;
          err += dx;
        }
      }
}



static void swap( int16_t a, int16_t b )
{
    int16_t c;

    c = b;
    b = a;
    a = c;
}


static void DrawFastVerticalLine( void* handle, int16_t x, int16_t y, int16_t h, uint16_t color)
{
    // Update in subclasses if desired!
    DrawLine(handle , x, y, x, y+h-1, color);
}

static void DrawFastHorizontalLine( void* handle, int16_t x, int16_t y, int16_t w, uint16_t color)
{
    // Update in subclasses if desired!
    DrawLine(handle, x, y, x+w-1, y, color);
}

static void FillRect( void* handle, int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)
{
    int16_t i;

    // Update in subclasses if desired!
    for (i=x; i<x+w; i++)
    {
        ILI9341_DrawFastVerticalLine(handle, i, y, h, color);
    }
}

static void WriteChar(void* handle, uint8_t c)
{
    if (c == '\n')
    {
        cursor_y += textsize*8;
        cursor_x  = 0;
    }
    else if (c == '\r')
    {
    // skip em
    }
    else
    {
        DrawChar(handle, cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
        cursor_x += textsize*6;
        if (wrap && (cursor_x > ( MAX_WIDTH - textsize*6)))
        {
          cursor_y += textsize*8;
          cursor_x = 0;
        }
    }
}

// Draw a character
void DrawChar(void* handle, int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size)
{

  if((x >= MAX_WIDTH)            || // Clip right
     (y >= MAX_HEIGHT)           || // Clip bottom
     ((x + 6 * size - 1) < 0) || // Clip left
     ((y + 8 * size - 1) < 0))   // Clip top
    return;

  if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

  for (int8_t i=0; i<6; i++ ) {
    uint8_t line;
    if (i == 5)
      line = 0x0;
    else
      line = pgm_read_byte(font+(c*5)+i);
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          ILI9341_DrawPixel( handle, x+i, y+j, color);
        else {  // big size
          FillRect(handle, x+(i*size), y+(j*size), size, size, color);
        }
      } else if (bg != color) {
        if (size == 1) // default size
          ILI9341_DrawPixel( handle, x+i, y+j, bg);
        else {  // big size
          FillRect( handle, x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
    }
  }
}

